#pragma once
#include "Compressors.h"
#include "Helpers.h"

#include <boost/asio.hpp>

#include <algorithm>
#include <array>
#include <cstddef>
#include <cstdint>
#include <expected>
#include <filesystem>
#include <fstream>
#include <future>
#include <map>
#include <ranges>
#include <string>

namespace dscstools::mdb1new
{
    template<typename T>
    concept ArchiveType = requires {
        typename T::InputStream;
        typename T::OutputStream;
        typename T::Header;
        typename T::TreeEntry;
        typename T::NameEntry;
        typename T::DataEntry;
        typename T::Compressor;
    } && Compressor<typename T::Compressor>;

    constexpr uint32_t MDB1_MAGIC_VALUE = 0x3142444d;

    enum class CompressMode
    {
        NONE,
        NORMAL,
        ADVANCED
    };

    struct MDB1Header32
    {
        uint32_t magicValue{MDB1_MAGIC_VALUE};
        uint16_t fileEntryCount;
        uint16_t fileNameCount;
        uint32_t dataEntryCount;
        uint32_t dataStart;
        uint32_t totalSize;
    };

    struct FileTreeEntry32
    {
        uint16_t compareBit;
        uint16_t dataId;
        uint16_t left;
        uint16_t right;
    };

    struct FileDataEntry32
    {
        uint32_t offset;
        uint32_t fullSize;
        uint32_t compressedSize;
    };

    struct MDB1Header64
    {
        uint32_t magicValue{MDB1_MAGIC_VALUE};
        uint32_t fileEntryCount;
        uint32_t fileNameCount;
        uint32_t dataEntryCount;
        uint64_t dataStart;
        uint64_t totalSize;
    };

    struct FileTreeEntry64
    {
        uint32_t compareBit;
        uint32_t dataId;
        uint32_t left;
        uint32_t right;
    };

    struct FileDataEntry64
    {
        uint64_t offset;
        uint64_t fullSize;
        uint64_t compressedSize;
    };

    template<size_t name_length, size_t extension_length>
    struct FileNameEntry
    {
        std::array<char, extension_length> extension{};
        std::array<char, name_length> name{};

        FileNameEntry() = default;
        FileNameEntry(std::string input)
        {
            std::copy(input.begin(), input.begin() + 4, extension.begin());
            std::copy(input.begin() + 4, input.end(), name.begin());
        }

        std::string toString()
        {
            std::string_view nameView(name.data(), name.size());
            std::string_view extensionView(extension.data(), extension.size());

            return std::format("{}.{}", trim(nameView), trim(extensionView));
        }
    };

    constexpr auto MDB1_CRYPTED_MAGIC_VALUE = 0x608D920C;
    // clang-format off
    const uint8_t CRYPT_KEY_1[997] = { 0xD3, 0x53, 0xD2, 0x85, 0xDC, 0x87, 0x77, 0xA7, 0x16, 0xFA, 0x8D, 0x45, 0x9D, 0x14, 0x60, 0x3B, 0x9B, 0x7B, 0xDA, 0xED, 0x25, 0xFD, 0xF5, 0x8D, 0x44, 0xD0, 0xEB, 0x8B, 0xAB, 0x4B, 0x6A, 0x3E, 0x01, 0x28, 0x63, 0xA3, 0xE3, 0x23, 0x63, 0xA3, 0xE2, 0x55, 0x6D, 0xA5, 0x7C, 0xA8, 0xE4, 0xF0, 0x8B, 0xAA, 0x7D, 0x74, 0x40, 0x9C, 0x47, 0x36, 0x9A, 0xAE, 0xB1, 0x19, 0x60, 0x3B, 0x9A, 0xAD, 0xE4, 0xEF, 0xBE, 0x82, 0x76, 0xDA, 0xED, 0x25, 0xFD, 0xF5, 0x8D, 0x45, 0x9C, 0x47, 0x37, 0x67, 0xD6, 0xB9, 0x81, 0xA8, 0xE3, 0x22, 0x96, 0x79, 0x40, 0x9C, 0x48, 0x04, 0x90, 0xAB, 0x4B, 0x6B, 0x0A, 0x5E, 0xA1, 0x48, 0x03, 0xC3, 0x83, 0x42, 0x35, 0xCD, 0x85, 0xDD, 0x55, 0x6C, 0xD7, 0x87, 0x76, 0xD9, 0x20, 0xFC, 0x28, 0x63, 0xA2, 0x15, 0x2D, 0x64, 0x6F, 0x3E, 0x02, 0xF6, 0x5A, 0x6D, 0xA5, 0x7D, 0x74, 0x3F, 0xCE, 0x51, 0x39, 0x00, 0x5C, 0x08, 0xC3, 0x82, 0x75, 0x0C, 0xF8, 0xF3, 0xF2, 0x26, 0xCA, 0x1E, 0x62, 0xD5, 0xED, 0x24, 0x30, 0xCC, 0xB8, 0xB3, 0xB3, 0xB2, 0xE6, 0x89, 0x11, 0xF9, 0xC0, 0x1B, 0xFA, 0x8E, 0x12, 0xC6, 0xE9, 0xF1, 0x58, 0xD4, 0x20, 0xFB, 0x5B, 0x3B, 0x9A, 0xAD, 0xE4, 0xF0, 0x8B, 0xAA, 0x7D, 0x74, 0x40, 0x9C, 0x47, 0x36, 0x9A, 0xAD, 0xE4, 0xF0, 0x8C, 0x77, 0xA7, 0x16, 0xFA, 0x8D, 0x45, 0x9C, 0x47, 0x36, 0x99, 0xE0, 0xBB, 0x1B, 0xFB, 0x5B, 0x3B, 0x9B, 0x7A, 0x0E, 0x91, 0x78, 0x73, 0x73, 0x72, 0xA5, 0x7D, 0x75, 0x0C, 0xF7, 0x26, 0xC9, 0x51, 0x38, 0x34, 0x00, 0x5C, 0x08, 0xC4, 0x50, 0x6C, 0xD7, 0x86, 0xAA, 0x7D, 0x75, 0x0C, 0xF7, 0x26, 0xC9, 0x50, 0x6B, 0x0B, 0x2A, 0xFE, 0xC2, 0xB6, 0x19, 0x60, 0x3C, 0x68, 0xA4, 0xB0, 0x4C, 0x38, 0x33, 0x32, 0x65, 0x3D, 0x34, 0x00, 0x5C, 0x07, 0xF6, 0x59, 0xA0, 0x7C, 0xA7, 0x16, 0xF9, 0xC1, 0xE8, 0x24, 0x2F, 0xFF, 0x8E, 0x12, 0xC6, 0xE9, 0xF0, 0x8C, 0x78, 0x74, 0x40, 0x9B, 0x7A, 0x0E, 0x91, 0x79, 0x41, 0x69, 0x71, 0xD9, 0x20, 0xFB, 0x5B, 0x3B, 0x9A, 0xAE, 0xB2, 0xE6, 0x8A, 0xDE, 0x22, 0x95, 0xAC, 0x18, 0x93, 0x12, 0xC5, 0x1D, 0x95, 0xAC, 0x18, 0x93, 0x13, 0x93, 0x12, 0xC6, 0xEA, 0xBD, 0xB5, 0x4C, 0x38, 0x34, 0x00, 0x5B, 0x3B, 0x9A, 0xAD, 0xE5, 0xBD, 0xB5, 0x4C, 0x38, 0x34, 0xFF, 0x8E, 0x11, 0xF8, 0xF4, 0xC0, 0x1B, 0xFB, 0x5B, 0x3B, 0x9A, 0xAE, 0xB2, 0xE5, 0xBD, 0xB5, 0x4D, 0x05, 0x5D, 0xD5, 0xED, 0x24, 0x30, 0xCC, 0xB8, 0xB4, 0x7F, 0x0F, 0x5E, 0xA2, 0x15, 0x2D, 0x64, 0x6F, 0x3E, 0x02, 0xF6, 0x59, 0xA1, 0x48, 0x03, 0xC2, 0xB6, 0x1A, 0x2E, 0x31, 0x98, 0x13, 0x93, 0x12, 0xC5, 0x1D, 0x95, 0xAD, 0xE4, 0xF0, 0x8C, 0x77, 0xA7, 0x16, 0xF9, 0xC1, 0xE9, 0xF1, 0x58, 0xD4, 0x20, 0xFB, 0x5B, 0x3A, 0xCD, 0x84, 0x10, 0x2C, 0x98, 0x14, 0x5F, 0x6E, 0x72, 0xA5, 0x7C, 0xA8, 0xE4, 0xEF, 0xBE, 0x81, 0xA9, 0xB0, 0x4B, 0x6B, 0x0A, 0x5D, 0xD4, 0x20, 0xFC, 0x27, 0x97, 0x47, 0x37, 0x66, 0x09, 0x90, 0xAB, 0x4A, 0x9E, 0xE2, 0x55, 0x6C, 0xD8, 0x54, 0x9F, 0xAE, 0xB2, 0xE6, 0x89, 0x11, 0xF9, 0xC0, 0x1C, 0xC7, 0xB6, 0x1A, 0x2E, 0x32, 0x66, 0x09, 0x91, 0x79, 0x41, 0x68, 0xA4, 0xB0, 0x4B, 0x6A, 0x3E, 0x02, 0xF6, 0x59, 0xA1, 0x48, 0x04, 0x90, 0xAB, 0x4B, 0x6A, 0x3E, 0x01, 0x28, 0x63, 0xA3, 0xE2, 0x56, 0x39, 0x01, 0x28, 0x63, 0xA2, 0x16, 0xF9, 0xC0, 0x1B, 0xFA, 0x8E, 0x11, 0xF9, 0xC1, 0xE9, 0xF1, 0x59, 0xA1, 0x48, 0x03, 0xC3, 0x82, 0x76, 0xD9, 0x20, 0xFC, 0x27, 0x96, 0x79, 0x40, 0x9B, 0x7B, 0xDA, 0xEE, 0xF1, 0x59, 0xA0, 0x7C, 0xA7, 0x17, 0xC7, 0xB7, 0xE6, 0x89, 0x11, 0xF9, 0xC1, 0xE9, 0xF1, 0x59, 0xA0, 0x7C, 0xA7, 0x16, 0xFA, 0x8D, 0x44, 0xCF, 0x1E, 0x62, 0xD5, 0xED, 0x25, 0xFD, 0xF4, 0xBF, 0x4E, 0xD1, 0xB8, 0xB3, 0xB2, 0xE5, 0xBC, 0xE7, 0x57, 0x06, 0x2A, 0xFE, 0xC2, 0xB5, 0x4D, 0x04, 0x8F, 0xDE, 0x22, 0x96, 0x79, 0x40, 0x9B, 0x7B, 0xDA, 0xED, 0x25, 0xFC, 0x28, 0x64, 0x70, 0x0C, 0xF7, 0x27, 0x97, 0x46, 0x6A, 0x3D, 0x35, 0xCC, 0xB7, 0xE7, 0x56, 0x3A, 0xCD, 0x84, 0x0F, 0x5E, 0xA1, 0x48, 0x04, 0x90, 0xAC, 0x18, 0x94, 0xDF, 0xEE, 0xF1, 0x59, 0xA1, 0x49, 0xD1, 0xB9, 0x80, 0xDC, 0x88, 0x43, 0x03, 0xC3, 0x82, 0x76, 0xD9, 0x20, 0xFB, 0x5B, 0x3A, 0xCE, 0x52, 0x06, 0x29, 0x31, 0x98, 0x14, 0x60, 0x3C, 0x67, 0xD7, 0x86, 0xAA, 0x7E, 0x42, 0x35, 0xCD, 0x85, 0xDD, 0x55, 0x6D, 0xA5, 0x7D, 0x75, 0x0D, 0xC5, 0x1D, 0x94, 0xE0, 0xBB, 0x1A, 0x2D, 0x64, 0x6F, 0x3E, 0x01, 0x29, 0x30, 0xCB, 0xEA, 0xBE, 0x81, 0xA9, 0xB0, 0x4C, 0x38, 0x34, 0xFF, 0x8F, 0xDE, 0x22, 0x95, 0xAD, 0xE5, 0xBD, 0xB5, 0x4C, 0x37, 0x66, 0x09, 0x91, 0x79, 0x40, 0x9C, 0x47, 0x37, 0x67, 0xD7, 0x86, 0xAA, 0x7D, 0x74, 0x40, 0x9C, 0x47, 0x37, 0x66, 0x09, 0x90, 0xAB, 0x4B, 0x6B, 0x0A, 0x5D, 0xD5, 0xEC, 0x58, 0xD3, 0x53, 0xD3, 0x53, 0xD3, 0x52, 0x06, 0x29, 0x30, 0xCC, 0xB8, 0xB4, 0x7F, 0x0F, 0x5F, 0x6F, 0x3E, 0x02, 0xF5, 0x8D, 0x45, 0x9D, 0x14, 0x5F, 0x6F, 0x3E, 0x01, 0x29, 0x31, 0x98, 0x13, 0x93, 0x13, 0x92, 0x45, 0x9D, 0x14, 0x5F, 0x6E, 0x71, 0xD8, 0x54, 0xA0, 0x7B, 0xDB, 0xBA, 0x4D, 0x05, 0x5C, 0x08, 0xC3, 0x82, 0x75, 0x0D, 0xC4, 0x4F, 0x9F, 0xAE, 0xB1, 0x19, 0x60, 0x3C, 0x68, 0xA4, 0xAF, 0x7F, 0x0E, 0x92, 0x45, 0x9D, 0x14, 0x60, 0x3C, 0x67, 0xD7, 0x86, 0xA9, 0xB0, 0x4C, 0x37, 0x67, 0xD6, 0xBA, 0x4D, 0x04, 0x90, 0xAB, 0x4A, 0x9D, 0x14, 0x5F, 0x6E, 0x72, 0xA6, 0x49, 0xD1, 0xB9, 0x80, 0xDB, 0xBB, 0x1B, 0xFA, 0x8D, 0x44, 0xCF, 0x1E, 0x62, 0xD6, 0xB9, 0x80, 0xDC, 0x87, 0x77, 0xA6, 0x49, 0xD1, 0xB9, 0x80, 0xDB, 0xBB, 0x1B, 0xFA, 0x8D, 0x44, 0xD0, 0xEB, 0x8A, 0xDE, 0x21, 0xC8, 0x84, 0x0F, 0x5E, 0xA1, 0x49, 0xD1, 0xB8, 0xB4, 0x80, 0xDC, 0x88, 0x43, 0x03, 0xC3, 0x83, 0x42, 0x35, 0xCD, 0x84, 0x0F, 0x5E, 0xA1, 0x48, 0x04, 0x8F, 0xDF, 0xEE, 0xF1, 0x59, 0xA0, 0x7C, 0xA7, 0x17, 0xC7, 0xB6, 0x19, 0x61, 0x08, 0xC4, 0x4F, 0x9F, 0xAE, 0xB1, 0x18, 0x93, 0x12, 0xC6, 0xEA, 0xBD, 0xB4, 0x80, 0xDC, 0x88, 0x44, 0xD0, 0xEB, 0x8B, 0xAB, 0x4B, 0x6B, 0x0B, 0x2A, 0xFE, 0xC2, 0xB6, 0x1A, 0x2D, 0x65, 0x3D, 0x35, 0xCC, 0xB8, 0xB4, 0x80, 0xDC, 0x88, 0x43, 0x03, 0xC2, 0xB5, 0x4D, 0x04, 0x8F, 0xDF, 0xEF, 0xBE, 0x81, 0xA8, 0xE3, 0x23, 0x63, 0xA2, 0x16, 0xF9, 0xC0, 0x1B, 0xFA, 0x8E, 0x11, 0xF9, 0xC1, 0xE9, 0xF0, 0x8B, 0xAA, 0x7E, 0x42, 0x35, 0xCD, 0x84, 0x10, 0x2C, 0x97, 0x46, 0x69, 0x70, 0x0C, 0xF7, 0x27, 0x97, 0x47, 0x37, 0x66, 0x0A, 0x5E, 0xA1, 0x49, 0xD0, 0xEC, 0x58, 0xD4, 0x20, 0xFC, 0x28, 0x64, 0x6F, 0x3E, 0x01, 0x28, 0x63, 0xA2, 0x15, 0x2C, 0x98, 0x14, 0x60, 0x3B, 0x9B };
    const uint8_t CRYPT_KEY_2[991] = { 0x92, 0x85, 0x1D, 0xD4, 0x60, 0x7B, 0x1B, 0x3B, 0xDB, 0xFA, 0xCE, 0x92, 0x85, 0x1D, 0xD5, 0x2D, 0xA4, 0xF0, 0xCB, 0x2A, 0x3D, 0x74, 0x80, 0x1B, 0x3B, 0xDB, 0xFA, 0xCD, 0xC5, 0x5C, 0x47, 0x77, 0xE7, 0x97, 0x87, 0xB6, 0x5A, 0xAD, 0x24, 0x6F, 0x7E, 0x82, 0xB6, 0x5A, 0xAD, 0x25, 0x3D, 0x75, 0x4C, 0x78, 0xB4, 0xC0, 0x5B, 0x7B, 0x1A, 0x6D, 0xE4, 0x2F, 0x3E, 0x42, 0x76, 0x1A, 0x6D, 0xE4, 0x30, 0x0C, 0x37, 0xA7, 0x57, 0x47, 0x76, 0x1A, 0x6E, 0xB1, 0x59, 0xE1, 0xC9, 0x91, 0xB9, 0xC1, 0x28, 0xA3, 0x22, 0xD5, 0x2C, 0xD7, 0xC7, 0xF6, 0x99, 0x21, 0x08, 0x03, 0x02, 0x35, 0x0C, 0x38, 0x73, 0xB3, 0xF2, 0x66, 0x49, 0x10, 0x6C, 0x17, 0x06, 0x6A, 0x7E, 0x82, 0xB5, 0x8C, 0xB8, 0xF4, 0x00, 0x9C, 0x87, 0xB6, 0x59, 0xE1, 0xC9, 0x90, 0xEC, 0x97, 0x87, 0xB7, 0x26, 0x0A, 0x9E, 0x21, 0x09, 0xD1, 0xF9, 0x01, 0x68, 0xE4, 0x2F, 0x3F, 0x0F, 0x9F, 0xEF, 0xFF, 0xCE, 0x92, 0x86, 0xE9, 0x31, 0xD8, 0x94, 0x20, 0x3B, 0xDB, 0xFA, 0xCE, 0x92, 0x85, 0x1C, 0x08, 0x03, 0x02, 0x36, 0xD9, 0x60, 0x7C, 0xE8, 0x63, 0xE3, 0x62, 0x15, 0x6D, 0xE5, 0xFD, 0x34, 0x3F, 0x0F, 0x9F, 0xEF, 0xFE, 0x02, 0x36, 0xDA, 0x2D, 0xA4, 0xEF, 0xFE, 0x01, 0x69, 0xB1, 0x59, 0xE0, 0xFB, 0x9B, 0xBA, 0x8D, 0x85, 0x1D, 0xD4, 0x60, 0x7B, 0x1B, 0x3B, 0xDB, 0xFB, 0x9A, 0xEE, 0x32, 0xA5, 0xBC, 0x28, 0xA3, 0x23, 0xA3, 0x23, 0xA3, 0x23, 0xA3, 0x22, 0xD6, 0xFA, 0xCE, 0x92, 0x86, 0xE9, 0x30, 0x0C, 0x38, 0x74, 0x7F, 0x4F, 0xDF, 0x2F, 0x3E, 0x41, 0xA8, 0x23, 0xA3, 0x23, 0xA3, 0x22, 0xD5, 0x2D, 0xA4, 0xF0, 0xCC, 0xF7, 0x67, 0x16, 0x39, 0x40, 0xDB, 0xFB, 0x9B, 0xBA, 0x8D, 0x84, 0x4F, 0xDE, 0x62, 0x16, 0x39, 0x40, 0xDC, 0xC7, 0xF6, 0x99, 0x21, 0x08, 0x04, 0xD0, 0x2C, 0xD8, 0x94, 0x1F, 0x6F, 0x7E, 0x82, 0xB5, 0x8D, 0x85, 0x1C, 0x08, 0x04, 0xD0, 0x2C, 0xD8, 0x93, 0x53, 0x12, 0x05, 0x9C, 0x88, 0x84, 0x4F, 0xDE, 0x61, 0x48, 0x44, 0x0F, 0x9E, 0x22, 0xD5, 0x2D, 0xA5, 0xBC, 0x28, 0xA4, 0xF0, 0xCB, 0x2B, 0x0A, 0x9D, 0x55, 0xAC, 0x58, 0x14, 0xA0, 0xBC, 0x28, 0xA3, 0x22, 0xD6, 0xF9, 0x00, 0x9B, 0xBA, 0x8E, 0x52, 0x45, 0xDC, 0xC7, 0xF7, 0x67, 0x17, 0x06, 0x69, 0xB1, 0x58, 0x13, 0xD2, 0xC6, 0x29, 0x71, 0x18, 0xD4, 0x5F, 0xAE, 0xF1, 0x98, 0x54, 0xE0, 0xFC, 0x68, 0xE4, 0x2F, 0x3F, 0x0E, 0xD1, 0xF9, 0x01, 0x69, 0xB1, 0x58, 0x14, 0x9F, 0xEE, 0x32, 0xA5, 0xBD, 0xF4, 0xFF, 0xCE, 0x91, 0xB9, 0xC0, 0x5B, 0x7B, 0x1B, 0x3A, 0x0D, 0x05, 0x9C, 0x87, 0xB6, 0x5A, 0xAE, 0xF2, 0x65, 0x7C, 0xE8, 0x63, 0xE3, 0x62, 0x15, 0x6C, 0x17, 0x07, 0x36, 0xD9, 0x61, 0x48, 0x43, 0x43, 0x42, 0x75, 0x4C, 0x78, 0xB3, 0xF3, 0x33, 0x72, 0xE6, 0xCA, 0x5E, 0xE1, 0xC8, 0xC3, 0xC3, 0xC3, 0xC2, 0xF6, 0x99, 0x21, 0x08, 0x04, 0xD0, 0x2C, 0xD8, 0x94, 0x1F, 0x6E, 0xB2, 0x26, 0x0A, 0x9E, 0x22, 0xD5, 0x2D, 0xA4, 0xEF, 0xFF, 0xCF, 0x5F, 0xAF, 0xBE, 0xC2, 0xF5, 0xCC, 0xF7, 0x66, 0x4A, 0xDE, 0x61, 0x49, 0x11, 0x39, 0x41, 0xA8, 0x24, 0x70, 0x4C, 0x77, 0xE7, 0x97, 0x86, 0xEA, 0xFD, 0x34, 0x40, 0xDB, 0xFA, 0xCE, 0x92, 0x86, 0xE9, 0x31, 0xD8, 0x93, 0x52, 0x46, 0xAA, 0xBD, 0xF5, 0xCD, 0xC5, 0x5D, 0x14, 0xA0, 0xBB, 0x5A, 0xAE, 0xF2, 0x65, 0x7C, 0xE7, 0x97, 0x86, 0xEA, 0xFD, 0x34, 0x3F, 0x0E, 0xD2, 0xC5, 0x5D, 0x15, 0x6D, 0xE5, 0xFD, 0x35, 0x0C, 0x37, 0xA7, 0x57, 0x47, 0x77, 0xE7, 0x97, 0x87, 0xB6, 0x59, 0xE1, 0xC8, 0xC4, 0x8F, 0x1E, 0xA2, 0x55, 0xAD, 0x24, 0x70, 0x4C, 0x77, 0xE7, 0x96, 0xB9, 0xC0, 0x5C, 0x47, 0x76, 0x1A, 0x6D, 0xE4, 0x2F, 0x3E, 0x41, 0xA9, 0xF1, 0x98, 0x53, 0x12, 0x06, 0x69, 0xB0, 0x8C, 0xB7, 0x26, 0x0A, 0x9D, 0x54, 0xDF, 0x2E, 0x72, 0xE5, 0xFD, 0x34, 0x3F, 0x0F, 0x9F, 0xEE, 0x32, 0xA5, 0xBD, 0xF4, 0xFF, 0xCF, 0x5E, 0xE1, 0xC9, 0x91, 0xB9, 0xC0, 0x5C, 0x48, 0x43, 0x42, 0x75, 0x4C, 0x78, 0xB3, 0xF2, 0x65, 0x7C, 0xE7, 0x96, 0xB9, 0xC1, 0x28, 0xA3, 0x22, 0xD5, 0x2D, 0xA5, 0xBC, 0x27, 0xD6, 0xF9, 0x01, 0x69, 0xB1, 0x58, 0x13, 0xD2, 0xC6, 0x2A, 0x3D, 0x75, 0x4D, 0x45, 0xDC, 0xC7, 0xF6, 0x99, 0x21, 0x09, 0xD0, 0x2C, 0xD7, 0xC7, 0xF7, 0x67, 0x16, 0x39, 0x41, 0xA8, 0x24, 0x6F, 0x7E, 0x82, 0xB6, 0x59, 0xE1, 0xC9, 0x90, 0xEC, 0x98, 0x53, 0x12, 0x05, 0x9C, 0x87, 0xB6, 0x5A, 0xAD, 0x25, 0x3C, 0xA8, 0x24, 0x70, 0x4C, 0x77, 0xE6, 0xCA, 0x5E, 0xE2, 0x95, 0xED, 0x64, 0xB0, 0x8B, 0xEB, 0xCB, 0x2B, 0x0A, 0x9D, 0x55, 0xAC, 0x58, 0x13, 0xD3, 0x92, 0x86, 0xEA, 0xFD, 0x34, 0x3F, 0x0E, 0xD1, 0xF8, 0x34, 0x40, 0xDC, 0xC8, 0xC4, 0x8F, 0x1E, 0xA1, 0x89, 0x50, 0xAB, 0x8A, 0x1D, 0xD5, 0x2D, 0xA4, 0xF0, 0xCB, 0x2B, 0x0A, 0x9D, 0x55, 0xAC, 0x57, 0x46, 0xA9, 0xF0, 0xCC, 0xF7, 0x67, 0x17, 0x07, 0x36, 0xDA, 0x2E, 0x71, 0x19, 0xA1, 0x88, 0x83, 0x83, 0x83, 0x82, 0xB6, 0x5A, 0xAD, 0x25, 0x3D, 0x74, 0x80, 0x1C, 0x08, 0x04, 0xCF, 0x5F, 0xAF, 0xBF, 0x8E, 0x51, 0x78, 0xB3, 0xF3, 0x32, 0xA5, 0xBD, 0xF5, 0xCD, 0xC4, 0x90, 0xEC, 0x97, 0x87, 0xB7, 0x27, 0xD7, 0xC6, 0x29, 0x70, 0x4B, 0xAB, 0x8B, 0xEB, 0xCB, 0x2A, 0x3D, 0x74, 0x7F, 0x4F, 0xDE, 0x62, 0x15, 0x6D, 0xE5, 0xFD, 0x34, 0x40, 0xDB, 0xFA, 0xCD, 0xC4, 0x90, 0xEB, 0xCA, 0x5E, 0xE1, 0xC9, 0x91, 0xB9, 0xC1, 0x28, 0xA4, 0xEF, 0xFF, 0xCE, 0x92, 0x85, 0x1D, 0xD4, 0x5F, 0xAE, 0xF2, 0x65, 0x7D, 0xB5, 0x8D, 0x84, 0x50, 0xAC, 0x57, 0x47, 0x76, 0x1A, 0x6E, 0xB1, 0x59, 0xE0, 0xFB, 0x9B, 0xBB, 0x5B, 0x7A, 0x4D, 0x45, 0xDD, 0x95, 0xED, 0x65, 0x7D, 0xB4, 0xBF, 0x8F, 0x1F, 0x6F, 0x7E, 0x81, 0xE9, 0x30, 0x0C, 0x37, 0xA6, 0x89, 0x50, 0xAC, 0x57, 0x46, 0xAA, 0xBD, 0xF5, 0xCC, 0xF7, 0x66, 0x4A, 0xDE, 0x61, 0x48, 0x44, 0x10, 0x6C, 0x18, 0xD4, 0x5F, 0xAF, 0xBE, 0xC1, 0x28, 0xA3, 0x23, 0xA2, 0x55, 0xAC, 0x58, 0x14, 0xA0, 0xBC, 0x28, 0xA4, 0xEF, 0xFF, 0xCF, 0x5E, 0xE1, 0xC8, 0xC4, 0x8F, 0x1E, 0xA1, 0x88, 0x83, 0x82, 0xB5, 0x8C, 0xB7, 0x27, 0xD6, 0xF9, 0x00, 0x9C, 0x87, 0xB6, 0x59, 0xE1, 0xC9, 0x90, 0xEC, 0x98, 0x53, 0x13, 0xD3, 0x93, 0x53, 0x12, 0x06, 0x6A, 0x7D, 0xB5, 0x8C, 0xB8, 0xF4, 0xFF, 0xCF, 0x5F, 0xAF, 0xBE, 0xC2, 0xF5, 0xCD, 0xC4, 0x8F, 0x1F, 0x6E, 0xB1, 0x59, 0xE1, 0xC8, 0xC4, 0x90, 0xEB, 0xCA, 0x5E, 0xE2, 0x95, 0xED, 0x64, 0xAF, 0xBE, 0xC1, 0x28, 0xA3, 0x23, 0xA3, 0x23, 0xA3, 0x23, 0xA2, 0x55, 0xAD, 0x25, 0x3D, 0x74, 0x7F, 0x4F, 0xDE, 0x62, 0x16, 0x39, 0x40, 0xDC, 0xC7, 0xF7, 0x67, 0x17, 0x06, 0x69, 0xB1, 0x58, 0x13, 0xD3, 0x93, 0x53, 0x13, 0xD2, 0xC5, 0x5C, 0x47, 0x77 };
    // clang-format on

    constexpr void cryptArray(char* array, std::size_t size, uint64_t offset)
    {
        for (int i = 0; i < size; i++)
            array[i] ^= CRYPT_KEY_1[(offset + i) % 997] ^ CRYPT_KEY_2[(offset + i) % 991];
    }

    template<std::size_t SIZE>
    constexpr void cryptArray(std::array<char, SIZE>& array, uint64_t offset)
    {
        cryptArray(array.data(), array.size(), offset);
    }

    class dscs_ifstream : public std::ifstream
    {
    public:
        dscs_ifstream(const std::filesystem::path path, std::ios::openmode mode)
            : std::ifstream(path, mode)
        {
        }

        std::istream& read(char* dst, std::streamsize count)
        {
            std::streampos offset = tellg();
            std::ifstream::read(dst, count);
            cryptArray(dst, count, offset);
            return *this;
        }
    };

    class dscs_ofstream : public std::ofstream
    {
        using std::ofstream::ofstream;

    public:
        dscs_ofstream(const std::filesystem::path path, std::ios::openmode mode)
            : std::ofstream(path, mode)
        {
        }

        std::ostream& write(char* dst, std::streamsize count)
        {
            cryptArray(dst, count, tellp());
            std::ofstream::write(dst, count);
            return *this;
        }
    };

    struct DSCS
    {
        using InputStream  = dscs_ifstream;
        using OutputStream = dscs_ofstream;
        using Header       = MDB1Header32;
        using TreeEntry    = FileTreeEntry32;
        using NameEntry    = FileNameEntry<0x3C, 4>;
        using DataEntry    = FileDataEntry32;
        using Compressor   = Doboz;

        static_assert(sizeof(Header) == 0x14);
        static_assert(sizeof(TreeEntry) == 0x08);
        static_assert(sizeof(NameEntry) == 0x40);
        static_assert(sizeof(DataEntry) == 0x0C);
    };

    struct DSCSNoCrypt
    {
        using InputStream  = std::ifstream;
        using OutputStream = std::ofstream;
        using Header       = MDB1Header32;
        using TreeEntry    = FileTreeEntry32;
        using NameEntry    = FileNameEntry<0x3C, 4>;
        using DataEntry    = FileDataEntry32;
        using Compressor   = Doboz;

        static_assert(sizeof(Header) == 0x14);
        static_assert(sizeof(TreeEntry) == 0x08);
        static_assert(sizeof(NameEntry) == 0x40);
        static_assert(sizeof(DataEntry) == 0x0C);
    };

    struct DSTS
    {
        using InputStream  = std::ifstream;
        using OutputStream = std::ofstream;
        using Header       = MDB1Header64;
        using TreeEntry    = FileTreeEntry64;
        using NameEntry    = FileNameEntry<0x7C, 4>;
        using DataEntry    = FileDataEntry64;
        using Compressor   = LZ4;

        static_assert(sizeof(Header) == 0x20);
        static_assert(sizeof(TreeEntry) == 0x10);
        static_assert(sizeof(NameEntry) == 0x80);
        static_assert(sizeof(DataEntry) == 0x18);
    };

    struct HLTLDA
    {
        using InputStream  = std::ifstream;
        using OutputStream = std::ofstream;
        using Header       = MDB1Header64;
        using TreeEntry    = FileTreeEntry64;
        using NameEntry    = FileNameEntry<0x7C, 4>;
        using DataEntry    = FileDataEntry64;
        using Compressor   = LZ4;

        static_assert(sizeof(Header) == 0x20);
        static_assert(sizeof(TreeEntry) == 0x10);
        static_assert(sizeof(NameEntry) == 0x80);
        static_assert(sizeof(DataEntry) == 0x18);
    };

    template<ArchiveType MDB>
    struct ArchiveInfo
    {
        ArchiveInfo(std::filesystem::path path);

        std::expected<void, std::string> extract(std::filesystem::path output);
        std::expected<void, std::string> extractSingleFile(std::filesystem::path output, std::string file);

    private:
        struct ArchiveEntry
        {
            uint64_t offset;
            uint64_t fullSize;
            uint64_t compressedSize;
        };

        MDB::InputStream input;
        std::map<std::string, ArchiveEntry> entries;
        uint64_t dataStart;

        std::expected<void, std::string> extractFile(std::filesystem::path output, const ArchiveEntry& entry);
    };

    template<ArchiveType MDB>
    std::expected<void, std::string>
    packArchive(std::filesystem::path source, std::filesystem::path target, CompressMode compress);

} // namespace dscstools::mdb1new

/* Implementation */
namespace dscstools::mdb1new::detail
{
    struct TreeName
    {
        std::string name;
        std::filesystem::path path;

        friend bool operator==(const TreeName& self, const TreeName& other) { return self.name == other.name; }
    };

    struct TreeNode
    {
        uint64_t compareBit;
        uint64_t left  = 0;
        uint64_t right = 0;
        TreeName name;
    };

    struct CompressionResult
    {
        uint64_t originalSize = 0;
        uint32_t crc          = 0;
        std::vector<char> data;
    };

    constexpr uint64_t INVALID = std::numeric_limits<uint64_t>::max();

    std::vector<TreeNode> generateTree(const std::vector<std::filesystem::path> paths, std::filesystem::path source);

    template<Compressor Compress>
    std::expected<CompressionResult, std::string> getFileData(std::filesystem::path file, CompressMode mode)
    {
        std::ifstream input(file, std::ios::in | std::ios::binary);

        if (!input.good())
            return std::unexpected(std::format("Error: something went wrong while decompressing {}", file.string()));

        auto size = std::filesystem::file_size(file);
        std::vector<char> data(size);
        input.read(data.data(), data.size());

        auto checksum = mode == CompressMode::ADVANCED ? getChecksum(data) : 0;

        if (size == 0 || Compress::isCompressed(data) || mode == CompressMode::NONE)
            return CompressionResult{.originalSize = data.size(), .crc = checksum, .data = data};

        auto compressed = Compress::compress(data).value_or(data);

        if (compressed.size() + 4 >= data.size()) compressed = data;

        return CompressionResult{
            .originalSize = data.size(),
            .crc          = checksum,
            .data         = compressed,
        };
    }
} // namespace dscstools::mdb1new::detail

// implementation
namespace dscstools::mdb1new
{
    using namespace detail;

    template<ArchiveType MDB>
    ArchiveInfo<MDB>::ArchiveInfo(std::filesystem::path path)
        : input(path, std::ios::in | std::ios::binary)
    {
        if (!input) return;

        auto header = read<typename MDB::Header>(input);

        dataStart = header.dataStart;

        assert(header.fileEntryCount == header.fileNameCount);

        std::vector<typename MDB::TreeEntry> treeEntries;
        std::vector<typename MDB::NameEntry> nameEntries;
        std::vector<typename MDB::DataEntry> dataEntries;
        for (int32_t i = 0; i < header.fileEntryCount; i++)
            treeEntries.push_back(read<typename MDB::TreeEntry>(input));
        for (int32_t i = 0; i < header.fileNameCount; i++)
            nameEntries.push_back(read<typename MDB::NameEntry>(input));
        for (int32_t i = 0; i < header.dataEntryCount; i++)
            dataEntries.push_back(read<typename MDB::DataEntry>(input));

        for (int32_t i = 0; i < treeEntries.size(); i++)
        {
            auto dataId = treeEntries[i].dataId;
            if (dataId == std::numeric_limits<decltype(dataId)>::max()) continue;
            auto data = dataEntries.at(dataId);

            entries[nameEntries[i].toString()] = {
                .offset         = data.offset,
                .fullSize       = data.fullSize,
                .compressedSize = data.compressedSize,
            };
        }
    }

    template<ArchiveType MDB>
    std::expected<void, std::string> ArchiveInfo<MDB>::extract(std::filesystem::path output)
    {
        if (std::filesystem::exists(output) && !std::filesystem::is_directory(output))
            return std::unexpected("Output path is not a directory.");
        if (output.has_parent_path()) std::filesystem::create_directories(output.parent_path());

        auto extract_fn = [this, output](const auto& key)
        {
            auto file = key.first;
            std::replace(file.begin(), file.end(), '\\', '/');
            std::filesystem::path path = output / file;

            return extractFile(path, key.second);
        };
        auto has_value_fn = [](const auto& value) { return !value.has_value(); };

        auto result = entries | std::views::transform(extract_fn) | std::views::filter(has_value_fn) |
                      std::ranges::to<std::vector<std::expected<void, std::string>>>();
        if (!result.empty()) return result[0];

        return {};
    }

    template<ArchiveType MDB>
    std::expected<void, std::string> ArchiveInfo<MDB>::extractSingleFile(std::filesystem::path output, std::string file)
    {
        std::replace(file.begin(), file.end(), '/', '\\');
        if (!entries.contains(file))
            return std::unexpected(std::format("File '{}' does not exist in the archive.", file));

        return extractFile(output, entries.at(file));
    }

    template<ArchiveType MDB>
    std::expected<void, std::string> ArchiveInfo<MDB>::extractFile(std::filesystem::path path,
                                                                   const ArchiveEntry& entry)
    {
        std::vector<char> inputData(entry.compressedSize);

        input.seekg(dataStart + entry.offset);
        input.read(inputData.data(), inputData.size());

        auto result = MDB::Compressor::decompress(inputData, entry.fullSize);
        if (!result) return std::unexpected(result.error());

        if (std::filesystem::exists(path) && !std::filesystem::is_regular_file(path))
            return std::unexpected("Output path already exists and isn't a file.");
        if (path.has_parent_path()) std::filesystem::create_directories(path.parent_path());

        typename MDB::OutputStream outputStream(path, std::ios::out | std::ios::binary);
        outputStream.write(result.value().data(), result.value().size());
        return {};
    }

    template<ArchiveType MDB>
    std::expected<void, std::string>
    packArchive(std::filesystem::path source, std::filesystem::path target, CompressMode compress)
    {
        if (!std::filesystem::exists(source) || !std::filesystem::is_directory(source))
            return std::unexpected("Source path does not exist or is not a directory.");
        if (target.has_parent_path() && !std::filesystem::exists(target))
            std::filesystem::create_directories(target.parent_path());

        std::vector<std::filesystem::path> files;

        for (auto i : std::filesystem::recursive_directory_iterator(source))
            if (std::filesystem::is_regular_file(i)) files.push_back(i);

        std::ranges::sort(files);

        log("[Pack] Generating File Tree...");
        auto tree = generateTree(files, source);

        // start compressing files
        std::map<std::string, std::promise<std::expected<CompressionResult, std::string>>> futureMap;
        // twice the core count to account for blocking threads
        size_t threadCount = std::thread::hardware_concurrency() * 2;
        boost::asio::thread_pool pool(threadCount);
        log(std::format("[Pack] Start compressing files with {} threads...", threadCount));

        for (const auto& file : tree)
        {
            if (file.compareBit == std::numeric_limits<decltype(file.compareBit)>::max()) continue;

            futureMap[file.name.name] = std::promise<std::expected<CompressionResult, std::string>>();

            auto lambda = [&]
            { futureMap[file.name.name].set_value(getFileData<typename MDB::Compressor>(file.name.path, compress)); };

            boost::asio::post(pool, lambda);
        }

        std::vector<typename MDB::TreeEntry> treeEntries;
        std::vector<typename MDB::NameEntry> nameEntries;
        std::vector<typename MDB::DataEntry> dataEntries;

        const auto fileCount     = files.size();
        const auto headerSize    = sizeof(typename MDB::Header);
        const auto treeEntrySize = sizeof(typename MDB::TreeEntry) * (fileCount + 1);
        const auto nameEntrySize = sizeof(typename MDB::NameEntry) * (fileCount + 1);
        const auto dataEntrySize = sizeof(typename MDB::DataEntry) * (fileCount);
        const auto dataStart     = headerSize + treeEntrySize + nameEntrySize + dataEntrySize;

        treeEntries.push_back({
            .compareBit = std::numeric_limits<decltype(MDB::TreeEntry::compareBit)>::max(),
            .dataId     = std::numeric_limits<decltype(MDB::TreeEntry::dataId)>::max(),
            .left       = 0,
            .right      = 1,
        });
        nameEntries.push_back({});

        auto fileId = 0;
        std::map<uint32_t, size_t> dataMap;
        size_t offset = 0;
        typename MDB::OutputStream output(target, std::ios::out | std::ios::binary);

        for (const auto& file : tree)
        {
            if (file.compareBit == std::numeric_limits<decltype(file.compareBit)>::max()) continue;

            if (fileId++ % 200 == 0) log(std::format("[Pack] Writing File {} of {}", fileId, fileCount));

            auto data = futureMap[file.name.name].get_future().get();
            if (!data) return std::unexpected(data.error());

            auto existingData = compress == CompressMode::ADVANCED ? dataMap.find(data->crc) : dataMap.end();
            auto dataId       = existingData == dataMap.end() ? dataEntries.size() : existingData->second;

            treeEntries.push_back({
                .compareBit = static_cast<decltype(MDB::TreeEntry::compareBit)>(file.compareBit),
                .dataId     = static_cast<decltype(MDB::TreeEntry::dataId)>(dataId),
                .left       = static_cast<decltype(MDB::TreeEntry::left)>(file.left),
                .right      = static_cast<decltype(MDB::TreeEntry::right)>(file.right),
            });
            nameEntries.emplace_back(file.name.name);
            if (existingData == dataMap.end())
            {
                dataMap[data->crc] = dataId;
                dataEntries.push_back({
                    .offset         = static_cast<decltype(MDB::DataEntry::offset)>(offset),
                    .fullSize       = static_cast<decltype(MDB::DataEntry::fullSize)>(data->originalSize),
                    .compressedSize = static_cast<decltype(MDB::DataEntry::compressedSize)>(data->data.size()),
                });

                output.seekp(dataStart + offset);
                output.write(data->data.data(), data->data.size());
                offset += data->data.size();
            }
        }

        output.seekp(0);
        typename MDB::Header header = {
            .fileEntryCount = static_cast<decltype(MDB::Header::fileEntryCount)>(treeEntries.size()),
            .fileNameCount  = static_cast<decltype(MDB::Header::fileNameCount)>(nameEntries.size()),
            .dataEntryCount = static_cast<decltype(MDB::Header::dataEntryCount)>(dataEntries.size()),
            .dataStart      = static_cast<decltype(MDB::Header::dataStart)>(dataStart),
            .totalSize      = static_cast<decltype(MDB::Header::totalSize)>(dataStart + offset),
        };

        output.write(reinterpret_cast<char*>(&header), headerSize);
        output.write(reinterpret_cast<char*>(treeEntries.data()), treeEntries.size() * sizeof(typename MDB::TreeEntry));
        output.write(reinterpret_cast<char*>(nameEntries.data()), nameEntries.size() * sizeof(typename MDB::NameEntry));
        output.write(reinterpret_cast<char*>(dataEntries.data()), dataEntries.size() * sizeof(typename MDB::DataEntry));
        return {};
    }
} // namespace dscstools::mdb1new